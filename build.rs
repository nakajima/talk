// build.rs
use std::env;
use std::fs;
use std::path::Path;
use syn::Fields;

// Add to your [build-dependencies] in Cargo.toml:
// syn = { version = "1.0", features = ["full"] }
// quote = "1.0"
// regex = "1.5"

fn main() {
    let out_dir = env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("instr_impls.rs");

    let instr_file_path = "src/lowering/instr.rs";
    println!("cargo:rerun-if-changed={}", instr_file_path);

    let content = fs::read_to_string(instr_file_path).unwrap();

    let generated_code = match syn::parse_file(&content) {
        Ok(file) => generate_impls(&file).unwrap_or_else(|e| {
            panic!("Failed to generate impls for Instr: {}", e);
        }),
        Err(e) => {
            panic!("Failed to parse src/lowering/instr.rs: {}", e);
        }
    };

    fs::write(&dest_path, generated_code).unwrap();
}

fn generate_impls(file: &syn::File) -> Result<String, Box<dyn std::error::Error>> {
    let instr_enum = file
        .items
        .iter()
        .find_map(|item| {
            if let syn::Item::Enum(e) = item {
                if e.ident == "Instr" {
                    return Some(e);
                }
            }
            None
        })
        .ok_or("Could not find 'enum Instr' in src/lowering/instr.rs")?;

    let display_impl = generate_display_impl(instr_enum);
    let from_str_impl = generate_from_str_impl(instr_enum); // Now fully implemented

    Ok(format!("{}\n{}", display_impl, from_str_impl))
}

fn get_doc_attr(attrs: &[syn::Attribute]) -> Option<String> {
    for attr in attrs {
        // Check for the built-in `#[doc]` attribute
        if attr.path.is_ident("doc") {
            // It's structured as `#[doc = "..."]`, which is a NameValue
            if let Ok(syn::Meta::NameValue(nv)) = attr.parse_meta() {
                if let syn::Lit::Str(lit) = nv.lit {
                    // Return the trimmed string content
                    return Some(lit.value().trim().to_string());
                }
            }
        }
    }
    None
}

fn generate_display_impl(instr_enum: &syn::ItemEnum) -> String {
    let mut match_arms = String::new();

    for variant in &instr_enum.variants {
        let variant_name = &variant.ident;
        let mut format_str = get_doc_attr(&variant.attrs)
            .unwrap_or_else(|| panic!("Variant {} is missing a #[text] attribute", variant_name));

        let (_field_names, field_pattern) = match &variant.fields {
            Fields::Named(fields) => {
                let names: Vec<_> = fields
                    .named
                    .iter()
                    .map(|f| f.ident.as_ref().unwrap().to_string())
                    .collect();
                for name in &names {
                    let placeholder = format!("${}", name);
                    format_str = format_str.replace(&placeholder, &format!("{{{}}}", name));
                }
                let field_pattern = format!("{{ {} }}", names.join(", "));
                (names, field_pattern)
            }
            Fields::Unnamed(fields) => {
                let names: Vec<_> = (0..fields.unnamed.len())
                    .map(|i| format!("v{}", i))
                    .collect();
                for (i, name) in names.iter().enumerate() {
                    let placeholder = format!("${}", i);
                    format_str = format_str.replace(&placeholder, &format!("{{{}}}", name));
                }
                let field_pattern = format!("({})", names.join(", "));
                (names, field_pattern)
            }
            Fields::Unit => (vec![], "".to_string()),
        };

        // let format_args = field_names.join(", ");
        match_arms.push_str(&format!(
            "            Self::{}{} => write!(f, \"{}\"),\n",
            variant_name, field_pattern, format_str
        ));
    }

    format!(
        "// This file is @generated by build.rs. Do not edit manually.\n\
         use std::fmt;\n\
         use crate::lowering::lowerer::*;
         use crate::lowering::instr::*;\n\n\
         impl fmt::Display for Instr {{\n\
         \tfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {{\n\
         \t\tmatch self {{\n\
         {}\
         \t\t}}\n\
         \t}}\n\
         }}",
        match_arms
    )
}

fn generate_from_str_impl(instr_enum: &syn::ItemEnum) -> String {
    let mut parser_arms = String::new();
    let placeholder_re = regex::Regex::new(r"\$([a-zA-Z0-9_]+)").unwrap();

    for variant in &instr_enum.variants {
        let variant_name = &variant.ident;
        let format_str = get_doc_attr(&variant.attrs).unwrap();

        let mut regex_str = String::from(r"^\s*");
        let mut last_end = 0;
        let mut captures = vec![];

        for mat in placeholder_re.find_iter(&format_str) {
            regex_str.push_str(&regex::escape(&format_str[last_end..mat.start()]));
            // Use non-greedy capture for everything.
            // Be aware that complex arguments with spaces might need better handling
            // in their FromStr impls or more specific regexes here.
            regex_str.push_str(r"\s*([^(]+?)\s*");
            last_end = mat.end();
            captures.push(mat.as_str()[1..].to_string());
        }
        regex_str.push_str(&regex::escape(&format_str[last_end..]));
        regex_str.push_str(r"\s*;?\s*$"); // Optional semicolon at the end

        let mut parsers = String::new();
        let mut constructor_args = String::new();
        use syn::__private::ToTokens;

        match &variant.fields {
            Fields::Named(fields) => {
                let mut args = vec![];
                for (i, cap_name) in captures.iter().enumerate() {
                    let field = fields
                        .named
                        .iter()
                        .find(|f| f.ident.as_ref().unwrap() == cap_name)
                        .unwrap();
                    let ty_str = field.ty.to_token_stream().to_string();
                    parsers.push_str(&format!(
                        "let {name} = caps.get({idx}).unwrap().as_str().trim().parse::<{ty}>().map_err(|e| e.to_string())?;\n",
                        name = cap_name,
                        idx = i + 1,
                        ty = ty_str
                    ));
                    args.push(cap_name.clone());
                }
                constructor_args = format!("{{ {} }}", args.join(", "));
            }
            Fields::Unnamed(fields) => {
                let mut args = vec![];
                for (i, field) in fields.unnamed.iter().enumerate() {
                    let ty_str = field.ty.to_token_stream().to_string();
                    parsers.push_str(&format!(
                        "let v{i} = caps.get({idx}).unwrap().as_str().trim().parse::<{ty}>().map_err(|e| e.to_string())?;\n",
                        i = i,
                        idx = i + 1,
                        ty = ty_str
                    ));
                    args.push(format!("v{}", i));
                }
                constructor_args = format!("({})", args.join(", "));
            }
            Fields::Unit => {}
        }

        parser_arms.push_str(&format!(
            "let re = regex::Regex::new(r#\"{}\"#).unwrap();\n\
             if let Some(caps) = re.captures(s) {{\n\
             log::trace!(\"regex parsing: {{:?}}\", caps);\n\
             \t{}\
             \treturn Ok(Self::{}{});\n\
             }}\n",
            regex_str, parsers, variant_name, constructor_args
        ));
    }

    format!(
        "
    use std::str::FromStr;
    use regex::Regex;

    impl FromStr for Instr {{
        type Err = String;

        fn from_str(s: &str) -> Result<Self, Self::Err> {{
            use crate::lowering::instr::*;
            use std::string::ToString;
            {}
            Err(format!(\"Could not parse instruction: '{{}}'\", s))
        }}
    }}
    ",
        parser_arms
    )
}
