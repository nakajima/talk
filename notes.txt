     ╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
     │ Comprehensive Type System Refactoring Plan                                                                              │
     │                                                                                                                         │
     │ Goal: Align with OutsideIn(X) architecture for clean, principled type inference with associated types                   │
     │                                                                                                                         │
     │ Core Architecture Changes                                                                                               │
     │                                                                                                                         │
     │ 1. Separate Type Constructors from Type Applications                                                                    │
     │                                                                                                                         │
     │ Problem: Ty::Nominal conflates type constructors (Person<A>) with type applications (Person<Int>)                       │
     │                                                                                                                         │
     │ Solution: Add Ty::TypeApp variant                                                                                       │
     │ enum Ty {                                                                                                               │
     │     // ... existing variants ...                                                                                        │
     │                                                                                                                         │
     │     // Type constructor reference (e.g., Person, Array)                                                                 │
     │     TypeCon(TypeId),                                                                                                    │
     │                                                                                                                         │
     │     // Type application: constructor applied to arguments                                                               │
     │     TypeApp {                                                                                                           │
     │         con: Box<Ty>,  // Must be TypeCon or another TypeApp                                                            │
     │         args: Vec<Ty>,                                                                                                  │
     │     },                                                                                                                  │
     │                                                                                                                         │
     │     // Nominal now only for fully instantiated types during constraint solving                                          │
     │     Nominal {                                                                                                           │
     │         id: TypeId,                                                                                                     │
     │         type_args: Vec<Ty>,  // Concrete instantiated args                                                              │
     │         row: Box<Row>,                                                                                                  │
     │     },                                                                                                                  │
     │ }                                                                                                                       │
     │                                                                                                                         │
     │ Rationale: This matches GHC/OCaml where type constructors are separate from applications. Makes type_args explicit and  │
     │ eliminates confusion.                                                                                                   │
     │                                                                                                                         │
     │ 2. Fix Scheme Representation                                                                                            │
     │                                                                                                                         │
     │ Problem: Initializer schemes incorrectly use Row::Param for all types                                                   │
     │                                                                                                                         │
     │ Solution: Only generic row polymorphism should use Row::Param                                                           │
     │ - For generic types Person<A>: type_args contains Param(A), row uses Row::Var                                           │
     │ - For non-generic types: type_args is empty, row uses Row::Var                                                          │
     │ - Row::Param only for actual row polymorphism (if we add it later)                                                      │
     │                                                                                                                         │
     │ Implementation:                                                                                                         │
     │ // In resolve_initializers:                                                                                             │
     │ let row = self.session.new_row_meta_var(Level(1)); // Always use Row::Var                                               │
     │ let ret = Ty::Nominal {                                                                                                 │
     │     id: type_id,                                                                                                        │
     │     type_args: generics.clone(), // [Param(A)] for generic, [] for non-generic                                          │
     │     row: Box::new(row),                                                                                                 │
     │ };                                                                                                                      │
     │                                                                                                                         │
     │ 3. Consistent Type Argument Population                                                                                  │
     │                                                                                                                         │
     │ Where type_args should be populated:                                                                                    │
     │                                                                                                                         │
     │ Construction constraint: Extract from scheme, instantiate with fresh metas ✓ (already done)                             │
     │                                                                                                                         │
     │ Member constraint: For method calls, extract from receiver's Nominal type ✓ (already done)                              │
     │                                                                                                                         │
     │ Type constructor declarations: Keep empty vec![] ✓ (already done)                                                       │
     │                                                                                                                         │
     │ After instantiation: Populated with metas/concrete types                                                                │
     │                                                                                                                         │
     │ 4. Eliminate Redundant Normalization                                                                                    │
     │                                                                                                                         │
     │ Current: 3+ normalize_with_catalog calls per type                                                                       │
     │                                                                                                                         │
     │ Target: 1 final zonking pass                                                                                            │
     │                                                                                                                         │
     │ Plan:                                                                                                                   │
     │ - Track type_args properly during constraint solving (Construction/Member)                                              │
     │ - Normalization only needed when AssociatedType appears                                                                 │
     │ - Add single "zonk" pass at end of inference to finalize all types                                                      │
     │ - Remove intermediate normalize calls from inference_pass.rs lines 166, 316, 506, 524, 545                              │
     │                                                                                                                         │
     │ 5. Constraint Solving Order                                                                                             │
     │                                                                                                                         │
     │ Follow OutsideIn(X) phases:                                                                                             │
     │ 1. Generation: Create constraints (already good)                                                                        │
     │ 2. Simplification: Solve simple constraints, defer complex ones (already good)                                          │
     │ 3. Defaulting: Handle ambiguous variables (add if needed)                                                               │
     │ 4. Zonking: Final substitution pass (add dedicated pass)                                                                │
     │                                                                                                                         │
     │ Implementation Steps                                                                                                    │
     │                                                                                                                         │
     │ Phase 1: Fix Current Broken State (immediate)                                                                           │
     │ 1. Revert Row::Param change in resolve_initializers - use Row::Var                                                      │
     │ 2. Keep type_args extraction in Construction/Member constraints                                                         │
     │ 3. Keep flexible unification (empty type_args matches any)                                                              │
     │ 4. Update 5 failing test assertions to expect type_args in output                                                       │
     │ 5. Verify tests pass                                                                                                    │
     │                                                                                                                         │
     │ Phase 2: Add TypeCon/TypeApp (refactor)                                                                                 │
     │ 1. Add Ty::TypeCon and Ty::TypeApp variants                                                                             │
     │ 2. Update parser/name resolver to emit TypeCon                                                                          │
     │ 3. Convert TypeApp to Nominal during constraint solving                                                                 │
     │ 4. Update all pattern matches                                                                                           │
     │ 5. Update instantiation logic                                                                                           │
     │                                                                                                                         │
     │ Phase 3: Clean Up Normalization (optimize)                                                                              │
     │ 1. Add dedicated zonk() pass after inference                                                                            │
     │ 2. Remove intermediate normalize_with_catalog calls                                                                     │
     │ 3. Keep normalize only for AssociatedType resolution                                                                    │
     │ 4. Measure performance improvement                                                                                      │
     │                                                                                                                         │
     │ Phase 4: Protocol Refinements (polish)                                                                                  │
     │ 1. Ensure associated type resolution uses type_args correctly                                                           │
     │ 2. Add better error messages                                                                                            │
     │ 3. Handle edge cases (nested generics, higher-kinded types)                                                             │
     │                                                                                                                         │
     │ Success Criteria                                                                                                        │
     │                                                                                                                         │
     │ - All tests pass                                                                                                        │
     │ - Type_args consistently populated                                                                                      │
     │ - Single normalization pass                                                                                             │
     │ - Code follows OutsideIn(X) principles                                                                                  │
     │ - Simpler, more maintainable codebase                                                                                   │
     ╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

     ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
     │ Comprehensive Type System Refactoring Plan                                                                               │
     │                                                                                                                          │
     │ Based on OutsideIn(X) Architecture with GADT Support                                                                     │
     │                                                                                                                          │
     │ Executive Summary                                                                                                        │
     │                                                                                                                          │
     │ We will transform our type system from an ad-hoc HM(X) implementation into a principled OutsideIn(X) system that         │
     │ properly handles:                                                                                                        │
     │ - Generic types with explicit type arguments                                                                             │
     │ - Associated types with lazy normalization                                                                               │
     │ - Protocol conformances (type classes)                                                                                   │
     │ - Future GADT support with implication constraints                                                                       │
     │ - Row polymorphism for structural typing                                                                                 │
     │                                                                                                                          │
     │ The key insight: OutsideIn(X) separates constraint generation (simple, compositional) from constraint solving (complex,  │
     │ with local assumptions). We currently conflate these, leading to redundant normalization and inconsistent type_args.     │
     │                                                                                                                          │
     │ ---                                                                                                                      │
     │ Part 1: Fundamental Type Representation                                                                                  │
     │                                                                                                                          │
     │ Problem Analysis                                                                                                         │
     │                                                                                                                          │
     │ Current state:                                                                                                           │
     │ - Ty::Nominal has type_args: Vec<Ty> but they're inconsistently populated                                                │
     │ - Type constructors (Person<A>) and type applications (Person<Int>) use same representation                              │
     │ - Row::Param misused - causes non-generic types to become Schemes                                                        │
     │ - Multiple normalize_with_catalog calls trying to "discover" type_args from structure                                    │
     │                                                                                                                          │
     │ Root cause:We're trying to use a single representation for three distinct concepts:                                      │
     │ 1. Type constructor declarations (Person<A> as a type family)                                                            │
     │ 2. Type constructor references (referring to Person in types)                                                            │
     │ 3. Fully applied nominal types (Person<Int> during solving)                                                              │
     │                                                                                                                          │
     │ Solution: Stratified Type Representation                                                                                 │
     │                                                                                                                          │
     │ pub enum Ty {                                                                                                            │
     │     // === Existing types (unchanged) ===                                                                                │
     │     Hole(NodeID),                                                                                                        │
     │     Primitive(Primitive),                                                                                                │
     │     Param(TypeParamId),           // Bound type variable (in forall)                                                     │
     │     Rigid(SkolemId),              // Skolem constant (for GADTs)                                                         │
     │     UnificationVar {                // Meta variable (inference)                                                         │
     │         id: UnificationVarId,                                                                                            │
     │         level: Level,                                                                                                    │
     │     },                                                                                                                   │
     │                                                                                                                          │
     │     Func(Box<Ty>, Box<Ty>),                                                                                              │
     │     Tuple(Vec<Ty>),                                                                                                      │
     │     Record(Box<Row>),                                                                                                    │
     │                                                                                                                          │
     │     // === NEW: Separate type constructor references ===                                                                 │
     │     // Type constructor reference - just the name                                                                        │
     │     // Example: Person (without type args)                                                                               │
     │     TypeCon(TypeId),                                                                                                     │
     │                                                                                                                          │
     │     // === NEW: Explicit type application ===                                                                            │
     │     // Type constructor applied to arguments                                                                             │
     │     // Example: Person<Int>, Array<Person<String>>                                                                       │
     │     // This is the "head normal form" of a type                                                                          │
     │     TypeApp {                                                                                                            │
     │         con: Box<Ty>,    // Must be TypeCon or another TypeApp                                                           │
     │         args: Vec<Ty>,                                                                                                   │
     │     },                                                                                                                   │
     │                                                                                                                          │
     │     // === CHANGED: Nominal types during constraint solving ===                                                          │
     │     // Fully instantiated nominal type WITH its row                                                                      │
     │     // Created during Construction/Member constraint solving                                                             │
     │     // type_args are concrete types (metas, primitives, other nominals)                                                  │
     │     Nominal {                                                                                                            │
     │         id: TypeId,                                                                                                      │
     │         type_args: Vec<Ty>,  // ALWAYS populated during solving                                                          │
     │         row: Box<Row>,       // Structural information                                                                   │
     │     },                                                                                                                   │
     │                                                                                                                          │
     │     // === CHANGED: Associated type projections ===                                                                      │
     │     // Lazy projection - doesn't normalize until needed                                                                  │
     │     // Example: T.Element where T: Iterable                                                                              │
     │     AssociatedType {                                                                                                     │
     │         base: Box<Ty>,                                                                                                   │
     │         protocol_id: TypeId,                                                                                             │
     │         associated_type_id: AssociatedTypeId,                                                                            │
     │     },                                                                                                                   │
     │ }                                                                                                                        │
     │                                                                                                                          │
     │ Key distinctions:                                                                                                        │
     │                                                                                                                          │
     │ 1. TypeCon: Just a name reference. Used in type annotations, scheme bodies.                                              │
     │   - Example: struct Person<A> { ... } - type constructor                                                                 │
     │   - In term_env: Symbol::Type(PersonId) -> Mono(TypeCon(PersonId))                                                       │
     │ 2. TypeApp: Type constructor with explicit arguments applied.                                                            │
     │   - Example: In code Person<Int> parses to TypeApp { con: TypeCon(PersonId), args: [Int] }                               │
     │   - In schemes: forall A. TypeApp { con: TypeCon(PersonId), args: [Param(A)] }                                           │
     │   - During inference: TypeApp { con: TypeCon(PersonId), args: [UnificationVar(meta1)] }                                  │
     │ 3. Nominal: Fully resolved, instantiated type with row structure.                                                        │
     │   - Only created during constraint solving (Construction, Member)                                                        │
     │   - Always has type_args populated                                                                                       │
     │   - Contains the structural row information                                                                              │
     │   - Example: After solving Person(age: 123) we get Nominal { id: PersonId, type_args: [Int], row: Extend{age: Int} }     │
     │                                                                                                                          │
     │ Migration path:                                                                                                          │
     │ - Parser emits TypeApp(TypeCon, args) for type annotations                                                               │
     │ - TypeResolvePass creates TypeApp in schemes                                                                             │
     │ - InferencePass converts TypeApp → Nominal when constructing/accessing                                                   │
     │ - Unification works on Nominal types                                                                                     │
     │                                                                                                                          │
     │ Row Representation (Unchanged But Clarified)                                                                             │
     │                                                                                                                          │
     │ pub enum Row {                                                                                                           │
     │     Empty(TypeDefKind),                                                                                                  │
     │     Extend { row: Box<Row>, label: Label, ty: Ty },                                                                      │
     │     Param(RowParamId),  // For actual row polymorphism (future feature)                                                  │
     │     Var(RowMetaId),     // Meta variable for row inference                                                               │
     │ }                                                                                                                        │
     │                                                                                                                          │
     │ Clarification:                                                                                                           │
     │ - Row::Param is for row polymorphism (open records, polymorphic variants)                                                │
     │ - Row::Var is for row inference (unification variables for structural types)                                             │
     │ - For generic types like Person<A>, the row uses Row::Var, NOT Row::Param                                                │
     │ - Row::Param would only be used for something like: func f<r>(x: {a: Int | r}) -> r                                      │
     │                                                                                                                          │
     │ ---                                                                                                                      │
     │ Part 2: Constraint System Architecture                                                                                   │
     │                                                                                                                          │
     │ Current Constraint Types (Keep These)                                                                                    │
     │                                                                                                                          │
     │ pub enum Constraint {                                                                                                    │
     │     Call(Call),              // Function application                                                                     │
     │     Equals(Equals),          // Type equality (unification)                                                              │
     │     HasField(HasField),      // Row has field                                                                            │
     │     Member(Member),          // Member access (methods, properties)                                                      │
     │     Construction(Construction), // Type construction                                                                     │
     │     Conforms(Conforms),      // Protocol conformance                                                                     │
     │     AssociatedEquals(AssociatedEquals), // Associated type equality                                                      │
     │     TypeMember(TypeMember),  // Type member access                                                                       │
     │ }                                                                                                                        │
     │                                                                                                                          │
     │ NEW: Implication Constraints (For GADTs)                                                                                 │
     │                                                                                                                          │
     │ // NEW constraint type for GADT support                                                                                  │
     │ pub struct Implication {                                                                                                 │
     │     pub assumptions: Vec<Constraint>,  // Local assumptions (e.g., a ~ Int from pattern match)                           │
     │     pub goal: Box<Constraint>,         // What we want to prove under assumptions                                        │
     │     pub span: Span,                                                                                                      │
     │ }                                                                                                                        │
     │                                                                                                                          │
     │ // Update Constraint enum                                                                                                │
     │ pub enum Constraint {                                                                                                    │
     │     // ... existing variants ...                                                                                         │
     │     Implication(Implication),  // NEW: Q₁,...,Qₙ => Q                                                                    │
     │ }                                                                                                                        │
     │                                                                                                                          │
     │ Purpose:                                                                                                                 │
     │ - GADT pattern matching generates local type equality assumptions                                                        │
     │ - These are tracked as implication constraints                                                                           │
     │ - Example: Matching Refl :: Eq a a reveals a ~ b locally                                                                 │
     │                                                                                                                          │
     │ Example GADT usage:                                                                                                      │
     │ enum Eq<A, B> {                                                                                                          │
     │     Refl<T>: Eq<T, T>,  // Constructor that proves A = B when A = B = T                                                  │
     │ }                                                                                                                        │
     │                                                                                                                          │
     │ func use_eq<A, B>(proof: Eq<A, B>, x: A) -> B {                                                                          │
     │     match proof {                                                                                                        │
     │         Refl => x  // Under assumption A ~ B, can return x as B                                                          │
     │     }                                                                                                                    │
     │ }                                                                                                                        │
     │                                                                                                                          │
     │ During pattern match on Refl:                                                                                            │
     │ 1. Generate local assumption: A ~ B (equality constraint)                                                                │
     │ 2. Create implication: (A ~ B) => (A equals B) for the match arm                                                         │
     │ 3. Solver can use assumption to type-check x as return value                                                             │
     │                                                                                                                          │
     │ ---                                                                                                                      │
     │ Part 3: Type Inference Pipeline (OutsideIn(X) Structure)                                                                 │
     │                                                                                                                          │
     │ Current Pipeline (4 passes)                                                                                              │
     │                                                                                                                          │
     │ 1. TypeHeadersPass - Gather type declarations                                                                            │
     │ 2. TypeResolvePass - Resolve types, create type catalog                                                                  │
     │ 3. DependenciesPass - Build dependency graph, resolve conformances                                                       │
     │ 4. InferencePass - Generate and solve constraints                                                                        │
     │                                                                                                                          │
     │ Refined Pipeline (Same 4 passes, clarified responsibilities)                                                             │
     │                                                                                                                          │
     │ Pass 1: TypeHeadersPass (Unchanged)                                                                                      │
     │                                                                                                                          │
     │ Purpose: Gather raw type declarations from AST                                                                           │
     │                                                                                                                          │
     │ Input: AST with resolved namesOutput: TypeSession with type_constructors map                                             │
     │                                                                                                                          │
     │ Actions:                                                                                                                 │
     │ - Walk AST, find all type declarations                                                                                   │
     │ - Record type names, fields, methods, protocols                                                                          │
     │ - NO type checking, just structural gathering                                                                            │
     │                                                                                                                          │
     │ Pass 2: TypeResolvePass (MAJOR CHANGES)                                                                                  │
     │                                                                                                                          │
     │ Purpose: Resolve type annotations and create type catalog entries                                                        │
     │                                                                                                                          │
     │ Key changes:                                                                                                             │
     │                                                                                                                          │
     │ 1. Emit TypeApp for user-written types:                                                                                  │
     │ // When user writes: struct Person<A> { let age: A }                                                                     │
     │ // Create scheme: forall A. (TypeApp Person [Param(A)]) -> TypeApp Person [Param(A)]                                     │
     │                                                                                                                          │
     │ 2. Forward declare types as TypeCon:                                                                                     │
     │ // In solve():                                                                                                           │
     │ for (type_id, type_def) in type_constructors {                                                                           │
     │     self.session.term_env.insert_mono(                                                                                   │
     │         Symbol::Type(type_id),                                                                                           │
     │         Ty::TypeCon(type_id),  // Just the constructor reference                                                         │
     │     );                                                                                                                   │
     │ }                                                                                                                        │
     │                                                                                                                          │
     │ 3. Initializer schemes use TypeApp in return type:                                                                       │
     │ // For Person<A> initializer:                                                                                            │
     │ fn resolve_initializers(...) {                                                                                           │
     │     let type_args = extract_params_from_generics(type_def);                                                              │
     │     let ret_ty = Ty::TypeApp {                                                                                           │
     │         con: Box::new(Ty::TypeCon(type_id)),                                                                             │
     │         args: type_args,  // [Param(A)] for generic, [] for non-generic                                                  │
     │     };                                                                                                                   │
     │     let params = map_initializer_params(init);                                                                           │
     │     let init_ty = curry(params, ret_ty);                                                                                 │
     │                                                                                                                          │
     │     // Now collect foralls - will find Param(A) in type_args                                                             │
     │     let foralls = init_ty.collect_foralls();                                                                             │
     │                                                                                                                          │
     │     if foralls.is_empty() {                                                                                              │
     │         term_env.insert_mono(init.symbol, init_ty);                                                                      │
     │     } else {                                                                                                             │
     │         term_env.promote(init.symbol, Scheme::new(foralls, vec![], init_ty));                                            │
     │     }                                                                                                                    │
     │ }                                                                                                                        │
     │                                                                                                                          │
     │ Critical fix: No more Row::Param for initializers! Always use Row::Var. Genericity comes from type_args containing       │
     │ Params, not from row.                                                                                                    │
     │                                                                                                                          │
     │ Pass 3: DependenciesPass (Unchanged)                                                                                     │
     │                                                                                                                          │
     │ Purpose: Build dependency graph, resolve protocol conformances                                                           │
     │                                                                                                                          │
     │ Input: TypeSessionOutput: TypeSession with type_catalog, conformances                                                    │
     │                                                                                                                          │
     │ Pass 4: InferencePass (REFACTORED)                                                                                       │
     │                                                                                                                          │
     │ Purpose: Generate constraints, solve them, generalize                                                                    │
     │                                                                                                                          │
     │ Structure follows OutsideIn(X):                                                                                          │
     │                                                                                                                          │
     │ impl InferencePass {                                                                                                     │
     │     // Main entry point                                                                                                  │
     │     pub fn perform(session: TypeSession<SCCResolved>, ast: &mut AST) -> TypeSession<Inferenced> {                        │
     │         let mut pass = InferencePass::new(session, ast);                                                                 │
     │                                                                                                                          │
     │         // Phase 1: Generate constraints for all top-level bindings                                                      │
     │         pass.generate_constraints();                                                                                     │
     │                                                                                                                          │
     │         // Phase 2: Solve constraints with fixed-point iteration                                                         │
     │         let (substitutions, unsolved) = pass.solve_constraints();                                                        │
     │                                                                                                                          │
     │         // Phase 3: Zonk all types (apply final substitutions)                                                           │
     │         pass.zonk_all(&substitutions);                                                                                   │
     │                                                                                                                          │
     │         // Phase 4: Generalize and promote bindings                                                                      │
     │         pass.generalize_bindings(&substitutions, &unsolved);                                                             │
     │                                                                                                                          │
     │         pass.finalize()                                                                                                  │
     │     }                                                                                                                    │
     │                                                                                                                          │
     │     fn solve_constraints(&mut self) -> (UnificationSubstitutions, Vec<Constraint>) {                                     │
     │         // Fixed-point constraint solving                                                                                │
     │         loop {                                                                                                           │
     │             let progress = self.solve_one_round();                                                                       │
     │             if !progress { break; }                                                                                      │
     │         }                                                                                                                │
     │         // Return final substitutions and unsolved constraints                                                           │
     │     }                                                                                                                    │
     │                                                                                                                          │
     │     fn zonk_all(&mut self, subs: &UnificationSubstitutions) {                                                            │
     │         // Walk all types in types_by_node                                                                               │
     │         // Apply substitutions, normalize AssociatedType projections                                                     │
     │         // This REPLACES the 4+ normalize_with_catalog calls scattered everywhere                                        │
     │     }                                                                                                                    │
     │ }                                                                                                                        │
     │                                                                                                                          │
     │ Key constraint solving changes:                                                                                          │
     │                                                                                                                          │
     │ 1. Construction constraint (ALREADY MOSTLY DONE):                                                                        │
     │ impl Construction {                                                                                                      │
     │     fn solve(&self, session, level, next_wants, subs) -> Result<bool> {                                                  │
     │         // 1. Look up initializer scheme                                                                                 │
     │         let init_entry = session.term_env.lookup(init_sym);                                                              │
     │                                                                                                                          │
     │         // 2. Extract TypeApp from scheme's return type                                                                  │
     │         let scheme_ret_type = extract_return_type(&init_entry);                                                          │
     │         let TypeApp { con, args: param_args } = scheme_ret_type;                                                         │
     │                                                                                                                          │
     │         // 3. Instantiate scheme (Params -> Metas)                                                                       │
     │         let (init_ty, inst_subs) = init_entry.solver_instantiate(...);                                                   │
     │                                                                                                                          │
     │         // 4. Instantiate type_args (substitute Params with Metas)                                                       │
     │         let instantiated_args = param_args.map(|p| instantiate_ty(p, &inst_subs, level));                                │
     │                                                                                                                          │
     │         // 5. Build property row by instantiating each property type                                                     │
     │         let row = build_property_row(properties, &inst_subs, level);                                                     │
     │                                                                                                                          │
     │         // 6. Create Nominal with instantiated type_args                                                                 │
     │         let instance = Ty::Nominal {                                                                                     │
     │             id: type_id,                                                                                                 │
     │             type_args: instantiated_args,  // [Meta(α7)] for Person<T>                                                   │
     │             row: Box::new(row),                                                                                          │
     │         };                                                                                                               │
     │                                                                                                                          │
     │         // 7. Unify                                                                                                      │
     │         unify(&self.returns, &instance, subs, vars)?;                                                                    │
     │         unify(&curry(args_with_self, instance), &init_ty, subs, vars)                                                    │
     │     }                                                                                                                    │
     │ }                                                                                                                        │
     │                                                                                                                          │
     │ 2. Member constraint (similar for methods):                                                                              │
     │ impl Member {                                                                                                            │
     │     fn solve(&self, session, level, next_wants, subs) -> Result<bool> {                                                  │
     │         let receiver = self.receiver.clone();                                                                            │
     │                                                                                                                          │
     │         // Handle GADT-style rigid types with protocol bounds                                                            │
     │         if let Ty::Rigid(skolem_id) = &receiver {                                                                        │
     │             // Look up protocol bounds for this skolem                                                                   │
     │             // Check if protocol has this member                                                                         │
     │             // Substitute Self with receiver                                                                             │
     │             // Unify                                                                                                     │
     │         }                                                                                                                │
     │                                                                                                                          │
     │         // Handle unification vars - defer                                                                               │
     │         if matches!(receiver, Ty::UnificationVar{..} | Ty::Param(_)) {                                                   │
     │             next_wants.push(Constraint::Member(self.clone()));                                                           │
     │             return Ok(false);                                                                                            │
     │         }                                                                                                                │
     │                                                                                                                          │
     │         // Handle Nominal types                                                                                          │
     │         if let Ty::Nominal { id, type_args, .. } = &receiver {                                                           │
     │             let nominal = session.type_catalog.nominals.get(id);                                                         │
     │             let sym = nominal.member_symbol(&self.label);                                                                │
     │             let entry = session.term_env.lookup(sym);                                                                    │
     │                                                                                                                          │
     │             // Instantiate method scheme                                                                                 │
     │             let method_ty = entry.solver_instantiate(...);                                                               │
     │                                                                                                                          │
     │             // For instance methods, first param is Self                                                                 │
     │             // Unify receiver with Self, then method type with expected type                                             │
     │             // ...                                                                                                       │
     │         }                                                                                                                │
     │                                                                                                                          │
     │         // Handle TypeApp - need to convert to Nominal first                                                             │
     │         if let Ty::TypeApp { con, args } = &receiver {                                                                   │
     │             // This shouldn't happen during solving - TypeApps should be                                                 │
     │             // converted to Nominals during Construction                                                                 │
     │             // But handle defensively by deferring                                                                       │
     │             next_wants.push(Constraint::Member(self.clone()));                                                           │
     │             return Ok(false);                                                                                            │
     │         }                                                                                                                │
     │                                                                                                                          │
     │         Ok(true)                                                                                                         │
     │     }                                                                                                                    │
     │ }                                                                                                                        │
     │                                                                                                                          │
     │ 3. AssociatedEquals constraint (ALREADY EXISTS, slight refactor):                                                        │
     │ impl AssociatedEquals {                                                                                                  │
     │     fn solve(&self, session, level, next_wants, subs) -> Result<bool> {                                                  │
     │         let subject = apply(self.subject.clone(), subs);                                                                 │
     │                                                                                                                          │
     │         // Only solve when subject is concrete (Nominal or TypeApp)                                                      │
     │         match &subject {                                                                                                 │
     │             Ty::Nominal { id, type_args, .. } |                                                                          │
     │             Ty::TypeApp { con: box Ty::TypeCon(id), args: type_args } => {                                               │
     │                 // Resolve witness: look up conformance                                                                  │
     │                 if let Some(witness) = resolve_witness(session, *id, self.protocol_id, self.assoc_id) {                  │
     │                     // Witness might have type params - substitute with type_args                                        │
     │                     let substituted_witness = substitute_witness(witness, type_args);                                    │
     │                     unify(&self.output, &substituted_witness, subs, vars)?;                                              │
     │                     Ok(true)                                                                                             │
     │                 } else {                                                                                                 │
     │                     Err(TypeError::MissingConformance(...))                                                              │
     │                 }                                                                                                        │
     │             }                                                                                                            │
     │             _ => {                                                                                                       │
     │                 // Defer until subject is known                                                                          │
     │                 next_wants.push(Constraint::AssociatedEquals(self.clone()));                                             │
     │                 Ok(false)                                                                                                │
     │             }                                                                                                            │
     │         }                                                                                                                │
     │     }                                                                                                                    │
     │ }                                                                                                                        │
     │                                                                                                                          │
     │ ---                                                                                                                      │
     │ Part 4: GADT Support (Future Addition)                                                                                   │
     │                                                                                                                          │
     │ GADT Syntax and Semantics                                                                                                │
     │                                                                                                                          │
     │ Proposed syntax:                                                                                                         │
     │ enum Eq<A, B> {                                                                                                          │
     │     case Refl<T>: Eq<T, T>  // Existential type T, proves A = B when A = B = T                                           │
     │ }                                                                                                                        │
     │                                                                                                                          │
     │ enum Vec<A, N> {                                                                                                         │
     │     case Nil: Vec<A, Zero>                                                                                               │
     │     case Cons<M>(A, Vec<A, M>): Vec<A, Succ<M>>                                                                          │
     │ }                                                                                                                        │
     │                                                                                                                          │
     │ Key feature: Constructor return types can be more specific than general enum type.                                       │
     │                                                                                                                          │
     │ Type Checking GADT Pattern Matches                                                                                       │
     │                                                                                                                          │
     │ Algorithm (based on OutsideIn(X)):                                                                                       │
     │                                                                                                                          │
     │ 1. During pattern matching on GADT constructor:                                                                          │
     │ // Matching: match expr { Refl => body }                                                                                 │
     │ // where expr: Eq<A, B>                                                                                                  │
     │                                                                                                                          │
     │ // Generate:                                                                                                             │
     │ // 1. Fresh skolem for existential: sk_T                                                                                 │
     │ // 2. Local equality assumptions: A ~ sk_T, B ~ sk_T                                                                     │
     │ // 3. Implication constraint: (A ~ sk_T, B ~ sk_T) => [constraints from body]                                            │
     │                                                                                                                          │
     │ 2. Skolemization:                                                                                                        │
     │ // When entering GADT pattern match arm:                                                                                 │
     │ fn check_gadt_pattern(&mut self, pattern: &Pattern, scrutinee_ty: &Ty, ...) {                                            │
     │     // 1. Get constructor's return type: Eq<T, T>                                                                        │
     │     let ctor_ret_ty = get_constructor_return_type(pattern);                                                              │
     │                                                                                                                          │
     │     // 2. Unify scrutinee Eq<A, B> with constructor Eq<T, T>                                                             │
     │     //    Generates: A ~ T, B ~ T                                                                                        │
     │     let equalities = unify_with_fresh_skolems(scrutinee_ty, ctor_ret_ty);                                                │
     │                                                                                                                          │
     │     // 3. Type-check body under equalities                                                                               │
     │     let body_constraints = self.check_expr_under_assumptions(body, &equalities);                                         │
     │                                                                                                                          │
     │     // 4. Create implication constraint                                                                                  │
     │     wants.push(Constraint::Implication(Implication {                                                                     │
     │         assumptions: equalities,                                                                                         │
     │         goal: body_constraints,                                                                                          │
     │     }));                                                                                                                 │
     │ }                                                                                                                        │
     │                                                                                                                          │
     │ 3. Solving implication constraints:                                                                                      │
     │ impl Implication {                                                                                                       │
     │     fn solve(&self, session, level, next_wants, subs) -> Result<bool> {                                                  │
     │         // Create a nested solving context with assumptions                                                              │
     │         let mut local_subs = subs.clone();                                                                               │
     │                                                                                                                          │
     │         // Apply assumptions to local context                                                                            │
     │         for assumption in &self.assumptions {                                                                            │
     │             match assumption {                                                                                           │
     │                 Constraint::Equals(eq) => {                                                                              │
     │                     unify(&eq.lhs, &eq.rhs, &mut local_subs, vars)?;                                                     │
     │                 }                                                                                                        │
     │                 _ => {                                                                                                   │
     │                     // Add to local constraint set                                                                       │
     │                 }                                                                                                        │
     │             }                                                                                                            │
     │         }                                                                                                                │
     │                                                                                                                          │
     │         // Try to solve goal under assumptions                                                                           │
     │         let result = self.goal.solve_under(session, level, &mut local_subs);                                             │
     │                                                                                                                          │
     │         // If successful, apply learned substitutions to outer context                                                   │
     │         if result.is_ok() {                                                                                              │
     │             merge_substitutions(subs, &local_subs);                                                                      │
     │             Ok(true)                                                                                                     │
     │         } else {                                                                                                         │
     │             // Defer or fail                                                                                             │
     │             next_wants.push(Constraint::Implication(self.clone()));                                                      │
     │             Ok(false)                                                                                                    │
     │         }                                                                                                                │
     │     }                                                                                                                    │
     │ }                                                                                                                        │
     │                                                                                                                          │
     │ Critical insight: Implication constraints capture "if we assume X, then Y follows". This is how GADTs work - pattern     │
     │ matching on a constructor gives us local type equalities that let us type-check the branch.                              │
     │                                                                                                                          │
     │ ---                                                                                                                      │
     │ Part 5: Lazy Normalization Strategy                                                                                      │
     │                                                                                                                          │
     │ Problem with Current Approach                                                                                            │
     │                                                                                                                          │
     │ Current: Eager normalization at multiple points (lines 166, 316, 506, 524, 545 in inference_pass.rs)                     │
     │ - After applying substitutions                                                                                           │
     │ - Before generalizing                                                                                                    │
     │ - After solving constraints                                                                                              │
     │ - Redundant, expensive, sometimes unnecessary                                                                            │
     │                                                                                                                          │
     │ Solution: Lazy Normalization (Rust/Chalk-style)                                                                          │
     │                                                                                                                          │
     │ Key idea: Don't normalize AssociatedType projections until we need to compare them with other types.                     │
     │                                                                                                                          │
     │ // Current (eager):                                                                                                      │
     │ let ty = T.Element;  // Immediately try to normalize to concrete type                                                    │
     │ normalize(ty);  // Expensive lookup                                                                                      │
     │                                                                                                                          │
     │ // Proposed (lazy):                                                                                                      │
     │ let ty = AssociatedType { base: T, ... };  // Keep as projection                                                         │
     │ // Only normalize when unifying:                                                                                         │
     │ unify(ty, some_other_type);  // Now we normalize                                                                         │
     │                                                                                                                          │
     │ Implementation:                                                                                                          │
     │                                                                                                                          │
     │ 1. Unification handles AssociatedType specially:                                                                         │
     │ fn unify(lhs: &Ty, rhs: &Ty, subs: &mut Subs, vars: &mut Vars) -> Result<bool> {                                         │
     │     let lhs = apply(lhs.clone(), subs);                                                                                  │
     │     let rhs = apply(rhs.clone(), subs);                                                                                  │
     │                                                                                                                          │
     │     match (&lhs, &rhs) {                                                                                                 │
     │         // NEW: Special case for associated types                                                                        │
     │         (Ty::AssociatedType { .. }, _) => {                                                                              │
     │             // Try to normalize the associated type                                                                      │
     │             if let Some(normalized) = try_normalize(&lhs, catalog) {                                                     │
     │                 unify(&normalized, rhs, subs, vars)                                                                      │
     │             } else {                                                                                                     │
     │                 // Can't normalize yet - create AssociatedEquals constraint                                              │
     │                 // This defers normalization until we know more                                                          │
     │                 Err(TypeError::CannotNormalize(lhs))                                                                     │
     │             }                                                                                                            │
     │         }                                                                                                                │
     │         (_, Ty::AssociatedType { .. }) => {                                                                              │
     │             // Symmetric case                                                                                            │
     │             if let Some(normalized) = try_normalize(&rhs, catalog) {                                                     │
     │                 unify(lhs, &normalized, subs, vars)                                                                      │
     │             } else {                                                                                                     │
     │                 Err(TypeError::CannotNormalize(rhs))                                                                     │
     │             }                                                                                                            │
     │         }                                                                                                                │
     │         // ... rest of unification ...                                                                                   │
     │     }                                                                                                                    │
     │ }                                                                                                                        │
     │                                                                                                                          │
     │ 2. Single zonking pass at end:                                                                                           │
     │ fn zonk_all(&mut self, subs: &UnificationSubstitutions) {                                                                │
     │     for (node_id, ty) in &mut self.session.types_by_node {                                                               │
     │         // 1. Apply all substitutions (replace metas with concrete types)                                                │
     │         let applied = apply(ty.clone(), subs);                                                                           │
     │                                                                                                                          │
     │         // 2. Normalize any remaining AssociatedType projections                                                         │
     │         //    At this point, most should be resolvable                                                                   │
     │         let normalized = normalize_with_catalog(applied, &self.session);                                                 │
     │                                                                                                                          │
     │         // 3. If still has AssociatedType, might be ambiguous - error or keep                                            │
     │         *ty = normalized;                                                                                                │
     │     }                                                                                                                    │
     │ }                                                                                                                        │
     │                                                                                                                          │
     │ 3. Remove redundant normalize_with_catalog calls:                                                                        │
     │ - Delete lines 166-170 (after apply_to_self)                                                                             │
     │ - Delete lines 316-320 (in apply_to_self loop)                                                                           │
     │ - Delete lines 506-509 (in infer_decl Let)                                                                               │
     │ - Delete lines 524-527 (in infer_decl Method)                                                                            │
     │ - Delete lines 545-548 (in infer_decl Func)                                                                              │
     │ - Keep ONLY the final zonk_all pass                                                                                      │
     │                                                                                                                          │
     │ Benefits:                                                                                                                │
     │ - Fewer expensive catalog lookups                                                                                        │
     │ - More natural - normalize when needed, not speculatively                                                                │
     │ - Easier to understand - one normalization point                                                                         │
     │ - Matches Chalk/Rust design                                                                                              │
     │                                                                                                                          │
     │ ---                                                                                                                      │
     │ Part 6: Implementation Roadmap                                                                                           │
     │                                                                                                                          │
     │ Phase 1: Fix Immediate Breakage (1-2 days)                                                                               │
     │                                                                                                                          │
     │ Goal: Get tests passing with current changes                                                                             │
     │                                                                                                                          │
     │ Tasks:                                                                                                                   │
     │ 1. Revert Row::Param in resolve_initializers to Row::Var                                                                 │
     │   - Change line 524: Row::Param(...) → self.session.new_row_meta_var(Level(1))                                           │
     │   - Genericity comes from type_args, not row params                                                                      │
     │ 2. Keep type_args extraction in Construction (already done correctly)                                                    │
     │ 3. Keep flexible unification for empty type_args (already done)                                                          │
     │ 4. Update failing test assertions:                                                                                       │
     │   - types_enum_constructor_with_generic_value: expect Type(TypeId(1)<[Int]>, ...) not Type(TypeId(1), ...)               │
     │   - Other 4 tests: examine failures, update assertions to match new type_args format                                     │
     │ 5. Verify all tests pass                                                                                                 │
     │                                                                                                                          │
     │ Success criteria: All 271 tests passing                                                                                  │
     │                                                                                                                          │
     │ Phase 2: Add TypeCon/TypeApp (3-5 days)                                                                                  │
     │                                                                                                                          │
     │ Goal: Separate type constructor references from applications                                                             │
     │                                                                                                                          │
     │ Tasks:                                                                                                                   │
     │                                                                                                                          │
     │ 1. Update Ty enum:                                                                                                       │
     │   - Add Ty::TypeCon(TypeId)                                                                                              │
     │   - Add Ty::TypeApp { con: Box<Ty>, args: Vec<Ty> }                                                                      │
     │   - Keep Ty::Nominal for constraint solving                                                                              │
     │ 2. Update parser/name resolver (if needed):                                                                              │
     │   - When parsing Person<Int>, emit TypeApp not Nominal                                                                   │
     │   - Type constructor references without args become TypeCon                                                              │
     │ 3. Update TypeResolvePass:                                                                                               │
     │   - Forward declarations: Ty::TypeCon(type_id) not Nominal                                                               │
     │   - Initializer return types: TypeApp { con: TypeCon(id), args: [Param(A)] }                                             │
     │   - Keep row as Row::Var always                                                                                          │
     │ 4. Update all pattern matches on Ty:                                                                                     │
     │   - Search for Ty::Nominal { id, row, .. } patterns                                                                      │
     │   - Add cases for TypeCon and TypeApp where needed                                                                       │
     │   - In most cases, TypeCon/TypeApp will be treated like Nominal                                                          │
     │ 5. Update collect_foralls:                                                                                               │
     │   - TypeCon: no foralls (just a reference)                                                                               │
     │   - TypeApp: collect from args                                                                                           │
     │   - Nominal: collect from type_args (as now)                                                                             │
     │ 6. Update instantiate_ty:                                                                                                │
     │   - TypeCon: unchanged                                                                                                   │
     │   - TypeApp: instantiate args                                                                                            │
     │   - Nominal: instantiate type_args (as now)                                                                              │
     │ 7. Update unification:                                                                                                   │
     │   - TypeApp vs TypeApp: unify constructors, then args                                                                    │
     │   - TypeApp vs Nominal: convert TypeApp to Nominal first? Or allow?                                                      │
     │   - Nominal vs Nominal: current logic (already correct)                                                                  │
     │ 8. Update Construction constraint:                                                                                       │
     │   - Extract TypeApp from scheme return type (not Nominal)                                                                │
     │   - Instantiate TypeApp's args                                                                                           │
     │   - Build Nominal for unification                                                                                        │
     │ 9. Test thoroughly:                                                                                                      │
     │   - Run all tests                                                                                                        │
     │   - Check that generics still work                                                                                       │
     │   - Check that type_args are populated correctly                                                                         │
     │                                                                                                                          │
     │ Success criteria: All tests passing, cleaner type representation                                                         │
     │                                                                                                                          │
     │ Phase 3: Implement Lazy Normalization (2-3 days)                                                                         │
     │                                                                                                                          │
     │ Goal: Single zonking pass, remove redundant normalizations                                                               │
     │                                                                                                                          │
     │ Tasks:                                                                                                                   │
     │                                                                                                                          │
     │ 1. Add zonk_all method to InferencePass:                                                                                 │
     │ fn zonk_all(&mut self, subs: &UnificationSubstitutions) {                                                                │
     │     let node_ids: Vec<_> = self.session.types_by_node.keys().copied().collect();                                         │
     │     for node_id in node_ids {                                                                                            │
     │         if let Some(ty) = self.session.types_by_node.get(&node_id).cloned() {                                            │
     │             let applied = apply(ty, subs);                                                                               │
     │             let normalized = normalize_with_catalog(applied, &self.session);                                             │
     │             self.session.types_by_node.insert(node_id, normalized);                                                      │
     │         }                                                                                                                │
     │     }                                                                                                                    │
     │ }                                                                                                                        │
     │                                                                                                                          │
     │ 2. Call zonk_all once in InferencePass::perform:                                                                         │
     │   - After final constraint solving                                                                                       │
     │   - Before generalization                                                                                                │
     │   - Line ~158: pass.annotate_uses_after_inference(); → add pass.zonk_all(&subs); before                                  │
     │ 3. Remove redundant normalize_with_catalog calls:                                                                        │
     │   - Line 166-170: Delete the normalization loop after solving                                                            │
     │   - Line 316-320: Delete normalize in apply_to_self                                                                      │
     │   - Line 506-509: Delete normalize in Let branch                                                                         │
     │   - Line 524-527: Delete normalize in Method branch                                                                      │
     │   - Line 545-548: Delete normalize in Func branch                                                                        │
     │ 4. Update unification to handle AssociatedType:                                                                          │
     │   - Add special case for AssociatedType in unify                                                                         │
     │   - Try to normalize, if fails, defer with AssociatedEquals constraint                                                   │
     │ 5. Test and benchmark:                                                                                                   │
     │   - Run all tests - should still pass                                                                                    │
     │   - Measure performance improvement (fewer catalog lookups)                                                              │
     │   - Verify normalization still happens correctly                                                                         │
     │                                                                                                                          │
     │ Success criteria: All tests passing, faster type checking, simpler code                                                  │
     │                                                                                                                          │
     │ Phase 4: Implication Constraints for GADTs (5-7 days)                                                                    │
     │                                                                                                                          │
     │ Goal: Add infrastructure for GADT support                                                                                │
     │                                                                                                                          │
     │ Tasks:                                                                                                                   │
     │                                                                                                                          │
     │ 1. Add Implication constraint type:                                                                                      │
     │   - Add struct Implication                                                                                               │
     │   - Add Constraint::Implication variant                                                                                  │
     │   - Update constraint apply/substitute methods                                                                           │
     │ 2. Add Ty::Rigid for skolems (already exists!):                                                                          │
     │   - Verify Rigid is used correctly                                                                                       │
     │   - Add skolem generation during GADT pattern matching                                                                   │
     │ 3. Add GADT parsing support (parser/AST changes):                                                                        │
     │   - Extend enum syntax: case Refl<T>: Eq<T, T>                                                                           │
     │   - Parse constructor with explicit return type                                                                          │
     │   - Store return type in AST                                                                                             │
     │ 4. Add GADT type checking in InferencePass:                                                                              │
     │   - In infer_pattern for match expressions                                                                               │
     │   - Generate skolems for existential type variables                                                                      │
     │   - Generate equality constraints from constructor return type                                                           │
     │   - Wrap body constraints in Implication                                                                                 │
     │ 5. Implement Implication solving:                                                                                        │
     │   - Create nested solving context                                                                                        │
     │   - Apply assumptions locally                                                                                            │
     │   - Solve goal under assumptions                                                                                         │
     │   - Propagate results back                                                                                               │
     │ 6. Add test cases:                                                                                                       │
     │   - Simple GADTs: Eq type, Vec with length                                                                               │
     │   - Pattern matching on GADTs                                                                                            │
     │   - Verify type refinement works                                                                                         │
     │                                                                                                                          │
     │ Success criteria: GADTs parse, type check, and tests pass                                                                │
     │                                                                                                                          │
     │ Phase 5: Cleanup and Optimization (2-3 days)                                                                             │
     │                                                                                                                          │
     │ Goal: Polish, document, optimize                                                                                         │
     │                                                                                                                          │
     │ Tasks:                                                                                                                   │
     │                                                                                                                          │
     │ 1. Add documentation:                                                                                                    │
     │   - Document OutsideIn(X) architecture in code comments                                                                  │
     │   - Explain type representation (TypeCon/TypeApp/Nominal)                                                                │
     │   - Document constraint solving algorithm                                                                                │
     │   - Add examples of GADT usage                                                                                           │
     │ 2. Improve error messages:                                                                                               │
     │   - Better errors for type mismatches                                                                                    │
     │   - Explain GADT refinement failures                                                                                     │
     │   - Show type_args in errors clearly                                                                                     │
     │ 3. Optimize performance:                                                                                                 │
     │   - Profile type checking                                                                                                │
     │   - Optimize hot paths (unification, apply, etc.)                                                                        │
     │   - Consider caching witness lookups                                                                                     │
     │ 4. Refactor for clarity:                                                                                                 │
     │   - Extract helper functions                                                                                             │
     │   - Reduce code duplication                                                                                              │
     │   - Improve naming                                                                                                       │
     │                                                                                                                          │
     │ Success criteria: Clean, documented, performant codebase                                                                 │
     │                                                                                                                          │
     │ ---                                                                                                                      │
     │ Part 7: Success Metrics and Validation                                                                                   │
     │                                                                                                                          │
     │ Correctness Metrics                                                                                                      │
     │                                                                                                                          │
     │ 1. All tests pass (271/271)                                                                                              │
     │ 2. Type_args consistently populated in Nominal types during solving                                                      │
     │ 3. Lazy normalization works - no redundant normalize calls                                                               │
     │ 4. GADTs type check correctly with proper refinement                                                                     │
     │                                                                                                                          │
     │ Performance Metrics                                                                                                      │
     │                                                                                                                          │
     │ 1. Reduce normalize_with_catalog calls from 4+ per type to 1 (zonking)                                                   │
     │ 2. Faster type checking (benchmark existing tests)                                                                       │
     │ 3. Less memory churn (fewer intermediate types created)                                                                  │
     │                                                                                                                          │
     │ Code Quality Metrics                                                                                                     │
     │                                                                                                                          │
     │ 1. Clear architecture following OutsideIn(X) principles                                                                  │
     │ 2. Good documentation explaining design decisions                                                                        │
     │ 3. Maintainable - easy to add new constraint types                                                                       │
     │ 4. Extensible - ready for future features (higher-kinded types, etc.)                                                    │
     │                                                                                                                          │
     │ ---                                                                                                                      │
     │ Appendix A: Key Insights from Research                                                                                   │
     │                                                                                                                          │
     │ OutsideIn(X) Core Principles                                                                                             │
     │                                                                                                                          │
     │ 1. Separate constraint generation from solving                                                                           │
     │   - Generation: Simple, compositional, local                                                                             │
     │   - Solving: Complex, global, with fixed-point iteration                                                                 │
     │ 2. Implication constraints for local assumptions                                                                         │
     │   - GADTs introduce local type equalities                                                                                │
     │   - Captured as (Q₁,...,Qₙ) => Q constraints                                                                             │
     │   - Solved in nested contexts                                                                                            │
     │ 3. Principled type inference                                                                                             │
     │   - Recover principal types by enriching type syntax                                                                     │
     │   - Use rigid types (skolems) for existentials                                                                           │
     │   - Stratified constraint solving                                                                                        │
     │                                                                                                                          │
     │ Lazy Normalization (Rust/Chalk)                                                                                          │
     │                                                                                                                          │
     │ 1. Don't normalize until needed                                                                                          │
     │   - Keep AssociatedType projections as-is                                                                                │
     │   - Normalize only when unifying with other types                                                                        │
     │   - Single zonking pass at end                                                                                           │
     │ 2. Benefits:                                                                                                             │
     │   - Fewer expensive lookups                                                                                              │
     │   - More compositional                                                                                                   │
     │   - Easier to reason about                                                                                               │
     │                                                                                                                          │
     │ Type Representation Best Practices                                                                                       │
     │                                                                                                                          │
     │ 1. Separate constructor references from applications                                                                     │
     │   - TypeCon: Just the name                                                                                               │
     │   - TypeApp: Applied to arguments                                                                                        │
     │   - Nominal: Fully resolved with structure                                                                               │
     │ 2. Explicit type arguments                                                                                               │
     │   - Always populate type_args during constraint solving                                                                  │
     │   - Makes witness resolution straightforward                                                                             │
     │   - Eliminates need to "discover" type args from rows                                                                    │
     │ 3. Row parameters vs row variables                                                                                       │
     │   - Row::Param for actual row polymorphism                                                                               │
     │   - Row::Var for row inference                                                                                           │
     │   - Don't conflate genericity with row polymorphism                                                                      │
     │                                                                                                                          │
     │ ---                                                                                                                      │
     │ Appendix B: Migration Safety                                                                                             │
     │                                                                                                                          │
     │ Backward Compatibility                                                                                                   │
     │                                                                                                                          │
     │ Breaking changes:                                                                                                        │
     │ - Ty enum gains new variants (TypeCon, TypeApp)                                                                          │
     │ - Implication constraint added                                                                                           │
     │ - Some APIs change (e.g., collect_foralls behavior)                                                                      │
     │                                                                                                                          │
     │ Non-breaking:                                                                                                            │
     │ - Existing constraint types unchanged                                                                                    │
     │ - Core unification algorithm unchanged                                                                                   │
     │ - Most test cases work as-is                                                                                             │
     │                                                                                                                          │
     │ Rollout Strategy                                                                                                         │
     │                                                                                                                          │
     │ 1. Phase 1 first - get tests passing with minimal changes                                                                │
     │ 2. Feature flag for TypeCon/TypeApp during Phase 2                                                                       │
     │ 3. Gradual migration of tests to expect new format                                                                       │
     │ 4. GADT support is purely additive (Phase 4)                                                                             │
     │                                                                                                                          │
     │ Testing Strategy                                                                                                         │
     │                                                                                                                          │
     │ 1. Keep all existing tests                                                                                               │
     │ 2. Add tests for new features (TypeApp, lazy normalization, GADTs)                                                       │
     │ 3. Benchmark before/after each phase                                                                                     │
     │ 4. Regression testing after each change                                                                                  │
     │                                                                                                                          │
     │ ---                                                                                                                      │
     │ Conclusion                                                                                                               │
     │                                                                                                                          │
     │ This plan transforms our type system from an ad-hoc collection of passes into a principled OutsideIn(X) implementation.  │
     │ The key insights:                                                                                                        │
     │                                                                                                                          │
     │ 1. Separate type constructor references from applications - makes type_args explicit and eliminates confusion            │
     │ 2. Use Row::Var for inference, Row::Param for actual row polymorphism - fixes the Mono/Scheme issue                      │
     │ 3. Lazy normalization with single zonking pass - eliminates redundant work                                               │
     │ 4. Implication constraints for GADT support - prepares us for advanced type features                                     │
     │                                                                                                                          │
     │ The implementation is phased to maintain stability, with each phase building on the previous one. We start by fixing     │
     │ immediate issues, then refactor the representation, optimize normalization, and finally add GADT support.                │
     │                                                                                                                          │
     │ The result: A clean, fast, maintainable type system that matches state-of-the-art implementations in GHC, Rust, and      │
     │ Swift.                                                                                                                   │
     ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯




